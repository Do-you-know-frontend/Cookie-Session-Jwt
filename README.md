# 쿠키세션웹토큰

HTTP는 항상 연결되어있는 것이 아닌 필요할 때마다 요청을 보내고 응답을 받는 비연결성이라는 특징을 가지고 있다. (**Connectionless 프로토콜 (비연결 지향) )**

이는 클라이언트가 응답을 받으면 서버는 접속을 끊는다는 것인데, 연결이 끝나면 상태 정보가 유지되지 않는 특성이 있다. (**Stateless 프로토콜)**

→ 로그인 정보를 유지하기 위한 방법이 쿠키와 세션

# 쿠키

:웹 서버가 HTTP 헤더 중 Set-Cookie 필드로 브라우저에게 보내는 4KB 이하의 작은 텍스트 파일이며, 사용자가 웹사이트를 이용하는 동안 사용자 브라우저에 저장

[활용]

: 팝업차단,지속적인 로그인 정보갱신, 장바구니 저장, 위치에 따른 정보 탐색 등

## 특징

- 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
- 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
- 하나의 도메인 당 20개의 쿠키를 가질 수 있다
- 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.

## 쿠키의 라이프타임

- *세션* 쿠키는 현재 세션이 끝날 때 삭제됩니다. 브라우저는 "현재 세션"이 끝나는 시점을 정의하며, 어떤 브라우저들은 재시작할 때 *세션을 복원*해 세션 쿠키가 무기한 존재할 수 있도록 합니다.
- *영속적인 쿠키*는 `Expires` 속성에 명시된 날짜에 삭제되거나, `Max-Age` 속성에 명시된 기간 이후에 삭제됩니다

## 보안취약점

## XSS(Cross-Site Scripting) 공격

XSS 공격은 **자바스크립트**가 사용자의 컴퓨터에서 실행된다는 점을 이용한 공격입니다. 페이지에 Script를 삽입하여 클라이언트측에서 해당 Script가 실행되게끔한다. 자바스크립트에서 "document.cookie"라는 명령어는 사이트에서 쿠키 값을 활용할 수 있게 하는 역할을 하지만 공격자들은 쿠키 값을 탈취하기 위해서 사용하기도 합니다.

`document.cookie = "Cookie Key:Cookie Value";`

### 대응방법

- XSS 방어 라이브러리 (ex>nodejs express의 helmet)
- 브라우저 확장앱
- 웹 방화벽
- Set-Cookie의 **HttpOnly**, SameSite ...

## ****Cookie의 보안정책/속성****

- SameSite: 쿠키를의 SameSite 정책을 의미합니다. 해당 설정에 따라 도메인 당 쿠키 설정이 제한됩니다.
- Domain: 쿠키를 전송할 도메인을 의미합니다. 해당 도메인에서만 쿠키가 유효해집니다.
- Path: 쿠키를 전송할 Path를 의미합니다. Path가 / 가 아닌 경우 지정된 페이지에서만 쿠키가 전송됩니다.
- Expires: 쿠키의 유효기간입니다. 파일 쿠키에 사용됩니다. (세션쿠키는 브라우저 탭 종료 시 만료됩니다)
- Secure: true로 설정되는 경우 TLS(https) 환경에서만 쿠키가 전송됩니다.
- HttpOnly: true로 설정되는 경우 Javascript에서 document.cookie로 접근할 수 없습니다.

### **[HttpOnly]**

HTTP 통신외에는 Cookie에 접근이 불가능하도록 하는것. HttpOnly Attribute를 가진 쿠키는 클라이언트에서 JavaScript를 통해 접근이 금지된다.

서버측에서는 HTTP 응답 헤더로서 Set-Cookie를 통해 클라이언트 측에 쿠키를 생성하도록 요청할 수 있다. 이때, Set-Cookie에는 다양한 Attrubtes을 통해 이 쿠키에 옵션을 부여할 수 있는데, HttpOnly도 그중에 하나이다.

하지만 Secure일지라도 민감한 정보는 절대 쿠키에 저장되면 안된다. 본질적으로 안전하지 않고 이 플래그가 당신에게 실질적인 보안(real protection)를 제공하지 않기 때문이다.

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly`

### HttpOnly가 가지는 한계점

- [SPA(Single Page Application)](https://dev-dain.tistory.com/46)
    
    근래의 웹페이지들은 편의성,속도등을 위해 SPA(Single Page Application)로 구현이 되어지고 있다. 이때 SPA는 한 페이지에서 많은 기능들을 수행하기위해 AJAX(Asynchronous JavaScript And XML)를 통해 서버와 통신한다.
    
- 만약에 [AJAX](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started)통신을 할때 cookie의 값을 서버에 전송해야 한다면?
    
    httpOnly 옵션을 가진 cookie는 JavaScript를 통해 접근하지 못한다. 접근을 하려면 `httpOnly = false`로 하는 수뿐이없다. 하지만 이는 XSS 공격으로부터 취약점이 생겨버리게 된다.
    
- XST(Cross-Site-Tracing) 공격 [참조](https://webhack.dynu.net/?idx=20161111.001)
    
    또한 2003년 XST(Cross-Site-Tracing) 공격을 통해 HttpOnly 방어책을 우회할수 있는 방법이 발견되어지며(현재 대부분의 브라우저에서 TRACE를 하지 못하게 되어있어 실현은 불가능하지만) httpOnly 만을 통해 cookie를 XSS공격으로부터 지키기엔 한계가 있다.
    

# 세션

**서버에 세션에 대한 정보(세션 상태, 클라이언트 상태, 세션 데이터 등)를 저장해 놓고 세션 쿠키( 고유한 세션 ID 값 )를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있도록 하는 방식**

[특징]

- 따로 용량의 제한이 없다 (서버의 능력에 따라 다를 수 있다)
- 서버에 세션 객체를 생성하며 각 클라이언트 마다 고유한 세션 ID 값을 부여한다
- 쿠키를 사용하여 세션 ID 값을 클라이언트에 보낸다
- 웹 브라우저가 종료되면 세션 쿠키는 삭제된다

세션 ID 를 쿠키에 포함하는 경우 XSS 공격을 통해, 클라이언트의 합법적인 세션 ID 를 획득하여 불법적으로 정상 사용자처럼 가장할 수 있다.

## 보안취약점

### ****CSRF 공격****

: 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격

아래와 같은 조건을 만족시켜서 요청.

- 위조 요청을 전송하는 서비스(페이스북)에 희생자가 로그인 상태
- 희생자가 해커가 만든 피싱 사이트에 접속

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/122f9bfb-8844-4583-92f9-f28913489de0/Untitled.png)

공격과정

1. 사용자는 보안이 취약한 서버에 로그인.
2. 로그인 이후 서버에 저장된 세션 정보를 사용할 수 있는 sessionID가 사용자 브라우저 쿠키에 저장됩니다.
3. 공격자는 서버에 인증된 브라우저의 사용자가 악성 스크립트 페이지를 누르도록 유도합니다.
    - ex1) 게시판에 악성 스크립트를 게시글로 작성하여 관리자 혹은 다른 사용자들이 게시글을 클릭하도록 유도합니다.
    - ex2) 메일 등으로 악성 스크립트를 직접 전달하거나, 악성 스크립트가 적힌 페이지 링크를 전달합니다.
4. 사용자가 악성 스크립트가 작성된 페이지 접근시 쿠키에 저장된 sessionID는 브라우저에 의해 자동적으로 함께 서버로 요청됩니다.
5. 서버는 쿠키에 담긴 sessionID를 통해 해당 요청이 인증된 사용자로부터 온 것으로 판단하고 처리합니다.

[방지방법]

1. Referer 체크 (요청이 어디서 왔는가?)
2. CSRF 토큰 (난수 생성해서 서버에서 확인하는 방법)

너무복잡해요 패스..

[CSRF(Cross-Site Request Forgery) 공격과 방어](https://junhyunny.github.io/information/security/spring-boot/spring-security/cross-site-reqeust-forgery/)

[](https://itstory.tk/entry/CSRF-%EA%B3%B5%EA%B2%A9%EC%9D%B4%EB%9E%80-%EA%B7%B8%EB%A6%AC%EA%B3%A0-CSRF-%EB%B0%A9%EC%96%B4-%EB%B0%A9%EB%B2%95)

# 쿠키세션 차이점 정리

1. 저장 위치
    
    쿠키: 클라이언트에 파일로 저장되어 있다
    
    세션: 서버에 저장되어 있다
    
2. 보안
    
    쿠키: 클라이언트의 브라우저 로컬에 저장되기 때문에 변질되거나 HTTP request 요청 시에 이를 갈취당할 수 있어서 보안에 취약하다
    
    세션: 쿠키를 이용해서 세션id만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적으로 안전하다
    
3. 라이프 사이클
    
    쿠키: 만료시간은 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아있다. 만료기간에 따라 상대적으로 넉넉하게 쿠키를 삭제할 때까지 유지된다
    
    세션: 만료기간을 정할 수는 있지만 브라우저가 종료되면 그에 상관없이 삭제된다
    
4. 속도
    
    쿠키: 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르다
    
    세션: 정보가 서버에 있기 때문에 처리가 요구되어 비교적으로 느리다
    

### **[Q. 세션을 사용하면 좋은데 왜 쿠키를 사용할까?](https://dev-coco.tistory.com/61#Q-%--%EC%--%B-%EC%--%--%EC%-D%--%--%EC%--%AC%EC%-A%A-%ED%--%--%EB%A-%B-%--%EC%A-%-B%EC%-D%--%EB%-D%B-%--%EC%--%-C%--%EC%BF%A-%ED%--%A-%EB%A-%BC%--%EC%--%AC%EC%-A%A-%ED%--%A-%EA%B-%-C%-F)**

**A.** 세션이 쿠키에 비해 보안이 높은 편이나 쿠키를 사용하는 이유는 세션은 서버에 저장되고, 서버의 자원을 사용하기에 서버 자원에 한계가 있고, 속도가 느려질 수 있기 때문에 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여 서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.

# jwt(json web token)

: 인증을 위한 정보를 **특별한 저장소를 이용하지 않고**, **전자 서명**을 이용하여 확인하는 방법

두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 (self-contained) 방식으로 정보를 안전성 있게 전달한다.

## 구성

header - 토큰의 타입 (jwt), 데이터 서명 방식
payload - 전달되는 데이터
signature - 헤더와 페이로드의 전자서명

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8706253f-7117-479f-8913-13e1f4564fb9/Untitled.png)

## 등장배경

- Cookie와 Session 사용시 문제점이였던 stateful 특성을 JWT 사용시 stateless하게 가져갈 수 있다. 즉 서버는 클라이언트의 상태를 가질 필요가 없다.
- MSA(Micro Service Architecture) 환경에서 유용하다.
- session은 기본적으로 웹 브라우저의 통신 스펙이라 모바일 앱 등, 웹 브라우저가 아닌 어플리케이션의 경우 이를 활용하기 부적합함(쿠키를 사용할 수 없는(쿠키는 웹브라우저에서 사용할수 있는 기능))
- JWT를 사용하면 어느 클라이언트에서나 동일한 방식의 사용자 인증을 구현 가능

단점:

- 거의 모든 요청에 토큰이 포함되므로 트래픽 크기에 영향을 미칠 수 있다.
- 토큰에 정보가 많아져 토큰의 크기가 커지면 네트워크에 부하를 줄 수 있다.
- 페이로드는 암호화된게 아니라 `BASE64`로 인코딩 된 것이므로 중간에 토큰을 탈취하면페이로드의 데이터를 모두 볼 수 있다.
    - **따라서 페이로드에는 중요 정보를 담아서는 안된다.**

## 어디에 저장해야할까?

### 방법1) access Token:js private변수, refresh: httponly쿠키

private 변수로 저장된 Access Token은 XSS 공격으로 탈취할 수 없고, 당연히 CSRF 공격을 당할 가능성도 없다.

**spa**의 경우 페이지를 이동하는것처럼 보여도 페이지가 실제로 이동하는 것이 아니기 때문에 private 변수가 그대로 유지됩니다. 단, 새로고침을 하면 변수가 날아갑니다. 때문에 이 경우에 추가로 Refresh Token만 가지고 Access Token을 발급받는 API를 만들어주어야 합니다.

**그럼 리프레쉬토큰이 httpOnly쿠키로 저장하는건 csrf공격에 위험하지않나?**

리프레쉬 토큰은 엑세스 토큰을 갱신하는 용도로만 사용된다. 서버에서는 새로운 토큰을 발급하기만 할 뿐 실제로 기존의 데이터베이스에는 변화가 없어서 괜찮다.

결정적으로 CSRF 공격으로는 발급받은 엑세스 토큰을 수령할 방법이 없다. 대부분의 웹 서비스의 경우 서버에서는 요청을 보낼 수 있는 클라이언트의 주소(Origin)를 한정하기 위해 요청에 담긴 헤더를 검증한다. 알지 못하는 클라이언트에서 요청을 가장한 공격을 보낼 것에 대비하기 위해서이다. 따라서 CSRF 공격을 통해 이를 우회하려면 요청 보내는 클라이언트의 주소를 위조할 수 밖에 없다. 하지만 이 방식의 단점은 요청을 보낸 쪽의 주소를 위조했으므로 서버는 그 위조된 주소에 응답을 보낼 것이라는 점이다. 즉 실제로 요청을 보낸 공격자의 페이지로는 응답이 오지 않는다. 다시 말해 그 응답에 담긴 엑세스 토큰을 탈취할 기회가 없다는 것이다. 따라서 리프레쉬 토큰은 httpOnly 쿠키로 저장해도 안전하다.

[[프로젝트] Refresh Token 적용하기](https://pomo0703.tistory.com/208#recentComments)

[Access Token과 Refresh Token을 어디에 저장해야 할까?](https://velog.io/@ohzzi/Access-Token%EA%B3%BC-Refresh-Token%EC%9D%84-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C)

[Refresh Token 도입기(F12)](https://medium.com/@uk960214/refresh-token-%EB%8F%84%EC%9E%85%EA%B8%B0-f12-dd79de9fb0f0)

### 방법2) CSRF 토큰

서버에 요청을 올린 페이지가 실제 서버에서 발행한 뷰 페이지가 맞는지 확인하는 것.
